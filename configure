#!/bin/sh
set -eu # to debug this script add '-x'

###############################################################################
# Prelude
###############################################################################
# The goal of this script is to automate the configuration and installation
# of packages that are needed to then compile and install semgrep itself.
# See also my https://github.com/aryx/xix/blob/master/configure for more info.

###############################################################################
# Helper functions
###############################################################################

ok()   { echo "  [OK]   $1"; }
warn() { echo "  [WARN] $1"; }
err()  { echo "  [ERR]  $1" >&2; }

errors=0

# Check that a command exists. Fatal if missing.
need_command() {
    if command -v "$1" >/dev/null 2>&1; then
        ok "$1 ($(command -v "$1"))"
    else
        err "$1 not found in PATH"
        errors=$((errors + 1))
    fi
}

# Check that a command exists. Only warns if missing.
want_command() {
    if command -v "$1" >/dev/null 2>&1; then
        ok "$1 ($(command -v "$1"))"
    else
        warn "$1 not found — $2"
    fi
}

# Check a C library via pkg-config, falling back to header lookup.
# This lets the check work on systems where a library is installed without a
# .pc file (e.g. libev on Ubuntu) and on macOS where pkg-config may not know
# about Homebrew-installed libs unless PKG_CONFIG_PATH is set.
check_c_lib() {
    local name pkg header search_dirs dir
    name="$1"    # human-readable label
    pkg="$2"     # pkg-config module name
    header="$3"  # representative header, relative to an include directory

    # Fast path: pkg-config finds it.
    if command -v pkg-config >/dev/null 2>&1 \
       && pkg-config --exists "$pkg" 2>/dev/null; then
        ok "$name (pkg-config: $pkg)"
        return 0
    fi

    # Fallback: scan common include directories for the header.
    search_dirs="/usr/include /usr/local/include"
    if command -v brew >/dev/null 2>&1; then
        search_dirs="$search_dirs $(brew --prefix 2>/dev/null)/include"
    fi

    for dir in $search_dirs; do
        if [ -f "$dir/$header" ]; then
            ok "$name (header: $dir/$header)"
            return 0
        fi
    done

    err "$name not found (pkg-config module '$pkg', header '$header')"
    errors=$((errors + 1))
}

# On macOS, Homebrew installs libraries outside the default pkg-config search
# path. Extend PKG_CONFIG_PATH once here so all subsequent pkg-config calls
# (tree-sitter detection, C library checks) benefit.
if command -v brew >/dev/null 2>&1; then
    _brew_prefix="$(brew --prefix 2>/dev/null || true)"
    if [ -n "$_brew_prefix" ]; then
        PKG_CONFIG_PATH="${_brew_prefix}/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
        export PKG_CONFIG_PATH
    fi
fi

###############################################################################
# Check required tools
###############################################################################

echo "Checking required tools..."

# OCaml toolchain
need_command ocaml
need_command opam

# Core build toolchain
need_command make
need_command git
need_command gcc

# curl: used by opam to download packages
need_command curl

# pkg-config: used by scripts/setup-tree-sitter.sh to detect a system
# tree-sitter library. Without it the script falls back to a local source
# build, so this is a warning rather than a hard error.
want_command pkg-config "tree-sitter will be built from source"

# Detect system tree-sitter early so we know whether autoconf/automake are
# needed. Coupling: REQUIRED_VERSION in scripts/setup-tree-sitter.sh.
_ts_required="0.20"
_ts_found=false
if command -v pkg-config >/dev/null 2>&1 \
   && pkg-config --exists tree-sitter 2>/dev/null \
   && pkg-config --atleast-version="$_ts_required" tree-sitter 2>/dev/null; then
    _ts_found=true
fi

# autoconf + automake: only needed when tree-sitter must be built from source.
if ! $_ts_found; then
    want_command autoconf "required to build tree-sitter from source"
    want_command automake "required to build tree-sitter from source"
fi

echo ""

###############################################################################
# Check git submodules
###############################################################################

echo "Checking git submodules..."

# libs/ocaml-tree-sitter-core is essential; an empty directory means
# 'git submodule update --init --recursive' was not run after cloning.
if [ -f "libs/ocaml-tree-sitter-core/configure" ]; then
    ok "libs/ocaml-tree-sitter-core (initialized)"
else
    err "libs/ocaml-tree-sitter-core is empty; run: git submodule update --init --recursive"
    errors=$((errors + 1))
fi

echo ""

###############################################################################
# Extra sanity checks
###############################################################################

echo "Checking environment..."

# OCaml version: >= 4.13 required; any 5.x is also supported.
# Check the active opam switch first (that is what the build uses); fall back
# to whatever 'ocaml' resolves to in PATH.
_ocaml_min_major=4
_ocaml_min_minor=13
_check_ocaml_version() {
    local ver label major minor
    ver="$1"
    label="$2"
    major=$(echo "$ver" | cut -d. -f1)
    minor=$(echo "$ver" | cut -d. -f2)
    if [ "$major" -gt "$_ocaml_min_major" ] \
       || { [ "$major" -eq "$_ocaml_min_major" ] && [ "$minor" -ge "$_ocaml_min_minor" ]; }; then
        ok "OCaml $ver ($label)"
    else
        err "OCaml $ver ($label) is too old; need >= ${_ocaml_min_major}.${_ocaml_min_minor} (4.x) or any 5.x"
        errors=$((errors + 1))
    fi
}

if command -v opam >/dev/null 2>&1 && [ -d "${OPAMROOT:-$HOME/.opam}" ]; then
    _switch=$(opam switch show 2>/dev/null || true)
    _opam_ver=$(opam exec -- ocaml --version 2>/dev/null \
                | grep -o '[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*' | head -1 || true)
    if [ -n "$_opam_ver" ]; then
        _check_ocaml_version "$_opam_ver" "opam switch: $_switch"
    else
        warn "could not determine OCaml version in opam switch '$_switch'"
    fi
elif command -v ocaml >/dev/null 2>&1; then
    _path_ver=$(ocaml --version | grep -o '[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*' | head -1)
    _check_ocaml_version "$_path_ver" "from PATH"
fi

# opam must have been initialized (opam init creates ~/.opam by default,
# or the directory pointed to by $OPAMROOT).
# opam >= 2.1 is also required: that is when depext support was integrated,
# allowing 'opam install' to automatically install system packages.
if command -v opam >/dev/null 2>&1; then
    _opam_root="${OPAMROOT:-$HOME/.opam}"
    if [ -d "$_opam_root" ]; then
        ok "opam initialized ($_opam_root)"
    else
        err "opam found but not initialized; run: opam init"
        errors=$((errors + 1))
    fi

    _opam_ver=$(opam --version 2>/dev/null | grep -o '[0-9][0-9]*\.[0-9][0-9]*' | head -1 || true)
    _opam_major=$(echo "$_opam_ver" | cut -d. -f1)
    _opam_minor=$(echo "$_opam_ver" | cut -d. -f2)
    if [ "$_opam_major" -gt 2 ] \
       || { [ "$_opam_major" -eq 2 ] && [ "$_opam_minor" -ge 1 ]; }; then
        ok "opam $_opam_ver (>= 2.1, depext supported)"
    else
        err "opam $_opam_ver is too old; need >= 2.1 for depext support"
        errors=$((errors + 1))
    fi
fi

echo ""

if [ "$errors" -ne 0 ]; then
    echo "$errors error(s) found. Please fix the issues above and re-run ./configure."
    exit 1
fi

###############################################################################
# Run setup
###############################################################################

echo "Running make setup (tree-sitter + opam deps)..."
make setup

echo ""

###############################################################################
# Verify C libraries installed by opam depext
###############################################################################

# These libraries are installed by 'make setup' via opam depext and are
# verified here as a post-install sanity check.
# Why each library is needed:
# - PCRE:    pattern matching used by spacegrep
# - PCRE2:   newer PCRE version used by the engine
# - GMP:     arbitrary-precision arithmetic, pulled in by cohttp (LGPL >= 6)
# - libev:   event loop, required by lwt (async I/O)
# - libcurl: HTTP client used by the networking/telemetry layer
# - tree-sitter: parsing library (optional: built from source if not found)
echo "Verifying C libraries installed by opam depext..."
check_c_lib "PCRE"    "libpcre"    "pcre.h"
check_c_lib "PCRE2"   "libpcre2-8" "pcre2.h"
check_c_lib "GMP"     "gmp"        "gmp.h"
check_c_lib "libev"   "libev"      "ev.h"
check_c_lib "libcurl" "libcurl"    "curl/curl.h"

# Report tree-sitter status (detection was done earlier).
if $_ts_found; then
    ok "tree-sitter (pkg-config: $(pkg-config --modversion tree-sitter))"
else
    warn "tree-sitter >= $_ts_required not found — will be compiled from source"
fi

if [ "$errors" -ne 0 ]; then
    echo "$errors C librar(ies) missing after setup. opam depext may have failed."
    exit 1
fi

###############################################################################
# Detect optional LSP servers for --lsp typed metavariables
###############################################################################

echo "Detecting optional LSP servers for --lsp..."

# find_lsp_server NAME CMD EXTRA_DIRS...
# Looks for CMD in PATH first, then in each EXTRA_DIR.
# Reports what was found (or not). Never fatal.
find_lsp_server() {
    local name cmd dir
    name="$1"; shift
    cmd="$1"; shift

    # Check PATH first
    if command -v "$cmd" >/dev/null 2>&1; then
        ok "$name ($cmd -> $(command -v "$cmd"))"
        return 0
    fi

    # Check additional directories
    for dir in "$@"; do
        if [ -x "$dir/$cmd" ]; then
            ok "$name ($dir/$cmd)"
            return 0
        fi
    done

    warn "$name ($cmd) not found — --lsp for this language will not work"
}

# ocamllsp: installed via opam, lives in the current opam switch bin dir
_opam_bin=""
if command -v opam >/dev/null 2>&1; then
    _opam_bin=$(opam var bin 2>/dev/null || true)
fi
find_lsp_server "OCaml LSP"  ocamllsp  ${_opam_bin:+"$_opam_bin"}

# clangd: usually in PATH via system package or LLVM install
find_lsp_server "C/C++ LSP"  clangd    /usr/lib/llvm-*/bin

# gopls: Go installs tools in ~/go/bin (GOPATH/bin) by default
_gobin="${GOBIN:-${GOPATH:-$HOME/go}/bin}"
find_lsp_server "Go LSP"     gopls     "$_gobin"

# rust-analyzer: Rust toolchain installs it in ~/.cargo/bin
find_lsp_server "Rust LSP"   rust-analyzer  "$HOME/.cargo/bin"

echo ''
echo 'Everything looks fine. You can now run: '
echo ''
echo '   $ make'
echo '   $ make install-semgrep-libs'
