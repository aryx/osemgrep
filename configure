#!/bin/sh
set -eu # to debug this script add '-x'

###############################################################################
# Prelude
###############################################################################
# The goal of this script is to automate the configuration and installation
# of packages that are needed to then compile and install semgrep itself.
# See also my https://github.com/aryx/xix/blob/master/configure for more info.

###############################################################################
# Helper functions
###############################################################################

ok()   { echo "  [OK]   $1"; }
warn() { echo "  [WARN] $1"; }
err()  { echo "  [ERR]  $1" >&2; }

errors=0

# Check that a command exists. Fatal if missing.
need_command() {
    if command -v "$1" >/dev/null 2>&1; then
        ok "$1 ($(command -v "$1"))"
    else
        err "$1 not found in PATH"
        errors=$((errors + 1))
    fi
}

# Check that a command exists. Only warns if missing.
want_command() {
    if command -v "$1" >/dev/null 2>&1; then
        ok "$1 ($(command -v "$1"))"
    else
        warn "$1 not found — $2"
    fi
}

# Check a C library via pkg-config, falling back to header lookup.
# This lets the check work on systems where a library is installed without a
# .pc file (e.g. libev on Ubuntu) and on macOS where pkg-config may not know
# about Homebrew-installed libs unless PKG_CONFIG_PATH is set.
check_c_lib() {
    local name pkg header search_dirs dir
    name="$1"    # human-readable label
    pkg="$2"     # pkg-config module name
    header="$3"  # representative header, relative to an include directory

    # Fast path: pkg-config finds it.
    if command -v pkg-config >/dev/null 2>&1 \
       && pkg-config --exists "$pkg" 2>/dev/null; then
        ok "$name (pkg-config: $pkg)"
        return 0
    fi

    # Fallback: scan common include directories for the header.
    search_dirs="/usr/include /usr/local/include"
    if command -v brew >/dev/null 2>&1; then
        search_dirs="$search_dirs $(brew --prefix 2>/dev/null)/include"
    fi

    for dir in $search_dirs; do
        if [ -f "$dir/$header" ]; then
            ok "$name (header: $dir/$header)"
            return 0
        fi
    done

    err "$name not found (pkg-config module '$pkg', header '$header')"
    errors=$((errors + 1))
}

# On macOS, Homebrew installs libraries outside the default pkg-config search
# path. Extend PKG_CONFIG_PATH once here so all subsequent pkg-config calls
# (tree-sitter detection, C library checks) benefit.
if command -v brew >/dev/null 2>&1; then
    _brew_prefix="$(brew --prefix 2>/dev/null || true)"
    if [ -n "$_brew_prefix" ]; then
        PKG_CONFIG_PATH="${_brew_prefix}/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
        export PKG_CONFIG_PATH
    fi
fi

###############################################################################
# Check required tools
###############################################################################

echo "Checking required tools..."

# Core build toolchain
need_command make
need_command git
need_command gcc

# OCaml toolchain
need_command ocaml
need_command opam

# curl: used by opam to download packages
need_command curl

# pkg-config: used by scripts/setup-tree-sitter.sh to detect a system
# tree-sitter library. Without it the script falls back to a local source
# build, so this is a warning rather than a hard error.
want_command pkg-config "tree-sitter will be built from source"

# Detect system tree-sitter early so we know whether autoconf/automake are
# needed. Coupling: REQUIRED_VERSION in scripts/setup-tree-sitter.sh.
_ts_required="0.20"
_ts_found=false
if command -v pkg-config >/dev/null 2>&1 \
   && pkg-config --exists tree-sitter 2>/dev/null \
   && pkg-config --atleast-version="$_ts_required" tree-sitter 2>/dev/null; then
    _ts_found=true
fi

# autoconf + automake: only needed when tree-sitter must be built from source.
if ! $_ts_found; then
    want_command autoconf "required to build tree-sitter from source"
    want_command automake "required to build tree-sitter from source"
fi

echo ""

###############################################################################
# Check git submodules
###############################################################################

echo "Checking git submodules..."

# libs/ocaml-tree-sitter-core is essential; an empty directory means
# 'git submodule update --init --recursive' was not run after cloning.
if [ -f "libs/ocaml-tree-sitter-core/configure" ]; then
    ok "libs/ocaml-tree-sitter-core (initialized)"
else
    err "libs/ocaml-tree-sitter-core is empty; run: git submodule update --init --recursive"
    errors=$((errors + 1))
fi

echo ""

###############################################################################
# Check required C libraries
###############################################################################

echo "Checking required C libraries..."

# Coupling: keep in sync with UBUNTU_DEPS / ALPINE_APK_DEPS_CORE / BREW_DEPS
# in the Makefile and the RUN apt-get line in the Dockerfile.
check_c_lib "PCRE"    "libpcre"    "pcre.h"
check_c_lib "PCRE2"   "libpcre2-8" "pcre2.h"
check_c_lib "GMP"     "gmp"        "gmp.h"
check_c_lib "libev"   "libev"      "ev.h"
check_c_lib "libcurl" "libcurl"    "curl/curl.h"

# Report tree-sitter status (detection was done earlier).
if $_ts_found; then
    ok "tree-sitter (pkg-config: $(pkg-config --modversion tree-sitter))"
else
    warn "tree-sitter >= $_ts_required not found — will be compiled from source"
fi

echo ""

###############################################################################
# Extra sanity checks
###############################################################################

echo "Checking environment..."

# OCaml version: >= 4.13 required; any 5.x is also supported.
# Check the active opam switch first (that is what the build uses); fall back
# to whatever 'ocaml' resolves to in PATH.
_ocaml_min_major=4
_ocaml_min_minor=13
_check_ocaml_version() {
    local ver label major minor
    ver="$1"
    label="$2"
    major=$(echo "$ver" | cut -d. -f1)
    minor=$(echo "$ver" | cut -d. -f2)
    if [ "$major" -gt "$_ocaml_min_major" ] \
       || { [ "$major" -eq "$_ocaml_min_major" ] && [ "$minor" -ge "$_ocaml_min_minor" ]; }; then
        ok "OCaml $ver ($label)"
    else
        err "OCaml $ver ($label) is too old; need >= ${_ocaml_min_major}.${_ocaml_min_minor} (4.x) or any 5.x"
        errors=$((errors + 1))
    fi
}

if command -v opam >/dev/null 2>&1 && [ -d "${OPAMROOT:-$HOME/.opam}" ]; then
    _switch=$(opam switch show 2>/dev/null || true)
    _opam_ver=$(opam exec -- ocaml --version 2>/dev/null \
                | grep -o '[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*' | head -1 || true)
    if [ -n "$_opam_ver" ]; then
        _check_ocaml_version "$_opam_ver" "opam switch: $_switch"
    else
        warn "could not determine OCaml version in opam switch '$_switch'"
    fi
elif command -v ocaml >/dev/null 2>&1; then
    _path_ver=$(ocaml --version | grep -o '[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*' | head -1)
    _check_ocaml_version "$_path_ver" "from PATH"
fi

# opam must have been initialized (opam init creates ~/.opam by default,
# or the directory pointed to by $OPAMROOT).
if command -v opam >/dev/null 2>&1; then
    _opam_root="${OPAMROOT:-$HOME/.opam}"
    if [ -d "$_opam_root" ]; then
        ok "opam initialized ($_opam_root)"
    else
        err "opam found but not initialized; run: opam init"
        errors=$((errors + 1))
    fi
fi

echo ""

if [ "$errors" -ne 0 ]; then
    echo "$errors error(s) found. Please fix the issues above and re-run ./configure."
    exit 1
fi

###############################################################################
# Run setup
###############################################################################

make setup

echo ''
echo 'Everything looks fine. You can now run: '
echo ''
echo '   $ make'
echo '   $ make install-semgrep-libs'
