(* OCaml (ocamllsp) helpers for the LSP client.
 *
 * Clean up the hover markdown returned by ocamllsp into a bare type string
 * suitable for Parse_ml.type_of_string.
 *
 * coupling: the format is generated by hover_req.ml in ocaml-lsp-server:
 *   https://github.com/ocaml/ocaml-lsp/blob/master/ocaml-lsp-server/src/hover_req.ml
 * - format_as_code_block wraps the type in ```ocaml ... ``` fences
 * - print_dividers joins sections with "\n***\n"
 * - sections are: [type code block; syntax doc (optional); doc comment (optional)]
 *
 * The format varies depending on the identifier:
 *
 * For stdlib operators like (||):
 *   "bool -> bool -> bool\n***\nThe boolean 'or'. Evaluation is ..."
 *
 * For local variables like 's':
 *   "string"
 *
 * For functions with doc:
 *   "```ocaml\nval read_file : Fpath.t -> string\n```\n---\nRead entire file."
 *
 * For type definitions:
 *   "type t = { foo : int; bar : string }"
 *)

open Common
module G = AST_generic

let project_root_marker = "dune-project"
let language_id = "ocaml"

(* Look for ocamllsp in the current opam switch *)
let server_cmd () =
  let opam_bin =
    try String.trim (UCmd.cmd_to_list "opam var bin" |> List.hd)
    with _exn -> "/usr/bin"
  in
  Filename.concat opam_bin "ocamllsp"

let clean_hover s =
  (* Step 1: strip markdown code fences if present.
   * e.g. "```ocaml\nval read_file : Fpath.t -> string\n```\n---\nRead..."
   *   -> "val read_file : Fpath.t -> string\n\n---\nRead..."
   *)
  let s =
    if s =~ "^```ocaml\n\\(.*\\)" then Common.matched1 s else s
  in
  let s = Str.global_replace (Str.regexp "```$") "" s in

  (* Step 2: remove documentation after separators.
   * ocamllsp separates the type from the doc with "\n***\n" or "\n---\n"
   * or "\n\n". We split on the first separator and keep only the type part.
   * e.g. "bool -> bool -> bool\n***\nThe boolean 'or'. Evaluation is ..."
   *   -> "bool -> bool -> bool"
   * e.g. "val read_file : Fpath.t -> string\n\n---\nRead entire file."
   *   -> "val read_file : Fpath.t -> string"
   *)
  let s =
    match Str.bounded_split (Str.regexp "\n\\*\\*\\*\n\\|\n---\n\\|\n\n") s 2 with
    | type_part :: _ -> type_part
    | [] -> s
  in

  (* Step 3: collapse newlines into spaces for multi-line type signatures.
   * e.g. "int ->\nstring ->\nbool"
   *   -> "int -> string -> bool"
   *)
  let s = Str.global_replace (Str.regexp "\n") " " s in

  let s = String.trim s in

  (* Step 4: extract the type name from type definitions, or pass through
   * simple types unchanged.
   * e.g. "type t = { foo : int; bar : string }" -> "t "  (the type name)
   * e.g. "type 'a option" -> "'a option"  (abstract type)
   * e.g. "sig ... end" -> "sig_TODO"  (module signatures, not handled)
   * e.g. "bool -> bool -> bool" -> "bool -> bool -> bool"  (unchanged)
   * e.g. "string" -> "string"  (unchanged)
   *)
  let s =
    match s with
    | _ when s =~ "^type \\([^=]+\\)=.*" -> Common.matched1 s
    | _ when s =~ "^type \\(.+\\)" -> Common.matched1 s
    | _ when s =~ "^sig .*" -> "sig_TODO"
    | _ -> s
  in
  s

let parse_type s =
  let ty = Parse_ml.type_of_string s in
  match Ocaml_to_generic.any (AST_ocaml.T ty) with
  | G.T ty -> ty
  | _ -> raise Impossible

let lsp_lang : LSP_lang.t = {
  server_cmd;
  language_id;
  project_root_marker;
  clean_hover;
  parse_type;
}
